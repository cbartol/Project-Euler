/*
 *	Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
 *
 *	Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
 *	Pentagonal	 	Pn=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
 *	Hexagonal	 	Hn=n(2n-1)	 	1, 6, 15, 28, 45, ...
 *	It can be verified that T285 = P165 = H143 = 40755.
 *
 *	Find the next triangle number that is also pentagonal and hexagonal.
 */

#include <iostream>
#include <stdio.h>
#include <cmath>
#include "../../auxx/convert.h"

double triangle(double n);
double triangle_inverse(double x);
double pentagonal(double n);
double hexagonal(double n);
bool isPentagonal(double t);
bool isHexagonal(double t);
void superTriangle(int n);

int main(){
	double x;
	double n = triangle_inverse(40755) + 1;
	x = triangle(n);
	while(!(isPentagonal(x) && isHexagonal(x))){
		n++;
		x = triangle(n);
	}
	superTriangle(n);
	std::cout << "Answer: " << x << " n: " << n << std::endl;
	return 0;
}

double triangle(double n){
	return n*(n+1)/2;
}
double triangle_inverse(double x){
	double n1;
	n1 = (-1 + sqrt(1+8*x))/2;
	if(n1 == floor(n1))
		return n1;
	return 0;
}
double pentagonal(double n){
	return n*(3*n-1)/2;
}
bool isPentagonal(double t){
	double n1;
	n1 = (1 + sqrt(1+24*t))/6;
	return (n1 == floor(n1));
}
double hexagonal(double n){
	return n*(2*n-1);
}
bool isHexagonal(double t){
	double n1;
	n1 = (1 + sqrt(1+8*t))/4;
	return (n1 == floor(n1));
}

void superTriangle(int n){
	int i, j;
	int buffer[10];
	int x = 0;
	std::vector<int> *xxx;
	i = (n+1)/2;
	xxx = int_to_vector(n);
	std::vector<int>::reverse_iterator it;
	for(x = 0, it = xxx->rbegin(); it != xxx->rend() ; it++, x++){
		buffer[x] = *it;
	}
	for(;x < 10 ; x++){
		buffer[x] = 0;
	}

	for(j = 0 ; j < 10 ; j++){
		buffer[j] *= i;
	}
	for(j = 0 ; j < 10 ; j++){
		while(buffer[j] >= 10){
			buffer[j] -= 10;
			buffer[j+1] += 1;
		}
	}
/*
	for(j = 0 ; j < COLUMN ; j++){
		while(buffer[j] >= 10){
			buffer[j] -= 10;
			buffer[j+1] += 1;
		}
	}*/
	printf("\n[");
	for(j = 10-1 ; j >= 0 ; j--){
		printf("%d", buffer[j]);
	}
	printf("]\n");
}
